$NetBSD: patch-ab,v 1.2 2013/11/24 05:53:52 dholland Exp $

- use standard headers
- don't provide own malloc/realloc declarations
- avoid implicit int
- declare void functions void
- fix os conditionals (apparently with respect to VMS)
- don't cast return value of malloc

--- charproc.c.orig	2001-06-06 13:05:15.000000000 +0000
+++ charproc.c
@@ -47,10 +47,13 @@ int eng_descent;
 #include <X11/Xmu/CharSet.h>
 #include <X11/Xmu/Converters.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <errno.h>
 #include <setjmp.h>
 #include <ctype.h>
 #include <X11/keysym.h>
+#include <sys/types.h>
+
 #include "hangul.h"
 #include "hstrdefs.h"
 
@@ -81,8 +84,6 @@ extern int font_minus_width_char_byte2;
 
 extern Widget toplevel;
 extern void exit();
-extern char *malloc();
-extern char *realloc();
 
 extern void FlushScroll();
 extern void InsertLine();
@@ -1764,7 +1765,7 @@ static void VTparse()
 	}
 }
 
-static finput()
+static int finput(void)
 {
 	return(doinput());
 }
@@ -1774,13 +1775,14 @@ static char *v_buffer;		/* pointer to ph
 static char *v_bufstr = NULL;	/* beginning of area to write */
 static char *v_bufptr;		/* end of area to write */
 static char *v_bufend;		/* end of physical buffer */
-#if !defined(linux) && !defined(SVR4)	/* dkim@surecom.com */
+#ifdef VMS
 #define	ptymask()	(v_bufptr > v_bufstr ? pty_mask : 0)
 #endif
 
 /* Write data to the pty as typed by the user, pasted with the mouse,
    or generated by us in response to a query ESC sequence. */
 
+int
 v_write(f, d, len)
     int f;
     char *d;
@@ -1802,7 +1804,7 @@ v_write(f, d, len)
 	fprintf(stderr, "\n");
 #endif
 
-#if defined(linux) || defined(SVR4)
+#ifndef VMS
 	if (f != pty_mask)
 #else
 	if ((1 << f) != pty_mask)
@@ -1927,7 +1929,7 @@ v_write(f, d, len)
 	return(c);
 }
 
-#if (defined(linux)||defined(SVR4))||(defined(hpux) && OSMAJORVERSION >= 10)
+#ifndef VMS
 static fd_set select_mask;
 static fd_set write_mask;
 #else
@@ -1936,6 +1938,7 @@ static int write_mask;
 #endif
 static int pty_read_bytes;
 
+int
 in_put()
 {
     register TScreen *screen = &term->screen;
@@ -1943,7 +1946,7 @@ in_put()
     static struct timeval select_timeout;
 
     for( ; ; ) {
-#if defined(linux)||defined(SVR4)||(defined(hpux) && OSMAJORVERSION >= 10)
+#ifndef VMS
 	if (FD_ISSET(pty_mask, &select_mask) && eventMode == NORMAL) {
 #else
 	if (select_mask & pty_mask && eventMode == NORMAL) {
@@ -2003,7 +2006,7 @@ in_put()
 		/* stop speed reading at some point to look for X stuff */
 		/* (4096 is just a random large number.) */
 		if (pty_read_bytes > 4096) {
-#if defined(linux)||defined(SVR4)||(defined(hpux) && OSMAJORVERSION >= 10)
+#ifndef VMS
 		    FD_CLR(pty_mask, &select_mask);
 #else
 		    select_mask &= ~pty_mask;
@@ -2033,7 +2036,7 @@ in_put()
 	/* Update the masks and, unless X events are already in the queue,
 	   wait for I/O to be possible. */
 	select_mask = Select_mask;
-#if defined(linux) || defined(SVR4) ||(defined(hpux) && OSMAJORVERSION >= 10)
+#ifndef VMS
 	if (v_bufptr > v_bufstr)
 	  FD_SET(pty_mask, &write_mask);
        else
@@ -2047,7 +2050,7 @@ in_put()
 /* by sangil's report */
 /* #if defined(linux)||defined(SVR4)
     ||(defined(hpux) && OSMAJORVERSION >= 10) */
-#if defined(linux)||defined(SVR4)
+#ifndef VMS
 	if (QLength (screen->display))
 	{
 	    i = select(max_plus1, (fd_set*) &select_mask, (fd_set*) &write_mask, (fd_set *)NULL, (struct timeval *) &select_timeout);
@@ -2073,7 +2076,7 @@ in_put()
 	} 
 
 	/* if there is room to write more data to the pty, go write more */
-#if defined(linux)||defined(SVR4)||(defined(hpux) && OSMAJORVERSION >= 10)
+#ifndef VMS
 	if ((v_bufptr > v_bufstr) && FD_ISSET(pty_mask, &write_mask)) {
 #else
 	if (write_mask & ptymask()) {
@@ -2083,7 +2086,7 @@ in_put()
 
 	/* if there are X events already in our queue, it
 	   counts as being readable */
-#if defined(linux)||defined(SVR4)||(defined(hpux) && OSMAJORVERSION >= 10)
+#ifndef VMS
 	if (QLength(screen->display) || (FD_ISSET(X_mask, &select_mask))) {
 #else
 	if (QLength(screen->display) || (select_mask & X_mask)) {
@@ -2322,6 +2325,7 @@ WriteText(screen, str, len, flags, fg, b
 /*
  * process ANSI modes set, reset
  */
+void
 ansi_modes(termw, func)
     XtermWidget	termw;
     int		(*func)();
@@ -2345,6 +2349,7 @@ ansi_modes(termw, func)
 /*
  * process DEC private modes set, reset
  */
+void
 dpmodes(termw, func)
     XtermWidget	termw;
     void (*func)();
@@ -2498,6 +2503,7 @@ dpmodes(termw, func)
 /*
  * process xterm private modes save
  */
+void
 savemodes(termw)
     XtermWidget termw;
 {
@@ -2564,6 +2570,7 @@ savemodes(termw)
 /*
  * process xterm private modes restore
  */
+void
 restoremodes(termw)
     XtermWidget termw;
 {
@@ -2711,6 +2718,7 @@ static void bitclr(p, mask)
 	*p &= ~mask;
 }
 
+void
 unparseseq(ap, fd)
     register ANSI *ap;
     int fd;
@@ -2744,6 +2752,7 @@ unparseseq(ap, fd)
 	}
 }
 
+void
 unparseputn(n, fd)
 unsigned int	n;
 int fd;
@@ -2756,6 +2765,7 @@ int fd;
 	unparseputc((char) ('0' + (n%10)), fd);
 }
 
+void
 unparseputc(c, fd)
 int c;
 int fd;
@@ -2774,6 +2784,7 @@ int fd;
 	}
 }
 
+void
 unparsefputs (s, fd)
     register char *s;
     int fd;
@@ -4062,7 +4073,7 @@ int LoadNewFont (screen, nfontname, bfon
 
     if (fontnum == fontMenu_fontescape &&
 	nfontname != screen->menu_font_names[fontnum]) {
-	tmpname = (char *) malloc (strlen(nfontname) + 1);
+	tmpname = malloc (strlen(nfontname) + 1);
 	if (!tmpname) return 0;
 	strcpy (tmpname, nfontname);
     }
@@ -4377,7 +4388,7 @@ set_vt_graphics (screen)
 	static char gr_valid_code[] = " `ajklmnopqrstuvwx~";
 
 	if (!gr_mapping) {
-		gr_mapping = (int *)malloc(sizeof(int)*256);
+		gr_mapping = malloc(sizeof(int)*256);
 		for(i = 0; i < 256; i++) {
 		    gr_mapping[i] = 1;
 		}
